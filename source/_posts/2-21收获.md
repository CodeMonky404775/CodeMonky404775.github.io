---
title: 2.21收获
date: 2021-02-22 22:49:39
tags:
---

# 2.21 收获

## 第46场双周赛

第一题 [5668. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)

这题数据量很小 直接暴力

但是我写得很丑

```C++
class Solution {
public:
    bool check(string s)
    {
        // 这里可以直接用hash表来做，但是时间比这种直接暴力遍历慢7 8 倍
        for(int i = 0;i < s.length();++i){
            bool has = false;
            for(int j = 0;j < s.length();++j){
                if((s[i] ^ s[j]) == 32)
                    has = true;
            }
            if(!has)
                return false;
        }
        return true;
    }
    string longestNiceSubstring(string s) {
         int n = s.length();        
         string res = "";
         for(int i = 0;i < n;++i) {
              for(int j = i;j < n;++j) {
                  string str = s.substr(i, j - i + 1);
                  if(check(str) && res.size() < str.size())
                    res = str;
              }
         }
         return res;
    }
};
```

**小技巧**：

s[i] ^ s[j] == 32 这个是用来判断两个字母是不是互为大小写字母

why？ 因为 在ascii表中，**大小写字母的差=32 也就是只有第五位是不一样的** 当两个字母异或只有第五位不一样的时候，此时两个字母就是互为大小写。

第二题 [5669. 通过连接另一个数组的子数组得到一个数组](https://leetcode-cn.com/problems/form-array-by-concatenating-subarrays-of-another-array/)

```C++
class Solution {
public:
    bool check(vector<int> g, vector<int> nums, int i) {
        int k = 0;
        for(int j = i; j < nums.size() && k < g.size();++j , ++k) {
            if(g[k] != nums[j]) return false;
        }
        if(k != g.size())  return false;
        return true;
    }
    bool canChoose(vector<vector<int>>& gs, vector<int>& nums) {
        int n = gs.size();
        for(int i = 0, k = 0; i < nums.size() ; ++ i) {
            if( check(gs[k], nums, i)) { 
                i += gs[k].size() - 1;
                k++;
                if(k == n) return true;
            }
        }
        return false;
    }
};
```

总结：发现y总这些高手对于stl的数据结构 和for的一些基础的用法都比我们要更加的熟练和高级，比如for里面就可以用的灵活，还有类似于判断大小写这种技巧，让代码变得更加优美

