---
title: 1.31 周日 学习内容
date: 2021-01-31 23:25:20
tags:
---
# 1.31 周日 学习总结

## 今日内容

### Linux操作系统

最近要做的东西是在公司的Linux项目上开发的，所以自己主动学了一下Linux的相关知识。在同事的推荐下看了《鸟哥的Linux私房菜》

这本书很适合入门，特别是没有接触过计算机开发的同学。
电子书一共有1770+页。

由于前面主要讲的是关于计算机的组成和操作系统的作用的。所以看的比较快，但是也很有收获
    

### 第0章和第1章的收获

​    

1. Linux的由来，与GNU C  Compiler(GCC)的历史
2. 重新了解了操作系统和计算机硬件以及软件应用的关系。大概是硬件->操作系统和驱动->软件的关系 
3. 感受了一下自由和开源的伟大，很希望自己也能成为上世纪Linux刚开始发育时期的那种Hacker
4. 同时了解到Linux是很适合建站的，最近的博客也是在macOS这个类Unix系统上完成的。大致了解应该怎么学Linux。

### 数据结构

1. leecode 每日一题 839 [相似字符串组] (https://leetcode-cn.com/problems/similar-string-groups/)
2. 第一次参加周赛 迟到了一个小时 写了两题但是时间过了

    1.  [从相邻元素对还原数组] (https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/) medium 我的方法是元素对往哈希表中正反填两次，头和尾的两个元素在哈希表中的v只会有一个值，其他的都是两个，这样找到头，然后根据键值直接索引到value，依次最后找到尾部。空间复杂度是O(2*n + n) 时间复杂度很高最开始遍历了两次n 最后依次找下一个节点的时候最坏情况是n^2 

        ```
        class Solution {
        public:
            vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {
                int n = adjacentPairs.size() + 1;
                if(n == 2)
                    return adjacentPairs[0];
                
                vector<int> res(n);
                unordered_map<int, vector<int>> map;
                for(int i = 0;i < n - 1;++i)
                {
                    map[adjacentPairs[i][0]].emplace_back(adjacentPairs[i][1]);
                    map[adjacentPairs[i][1]].emplace_back(adjacentPairs[i][0]);
                }
                res[n - 1] = INT32_MIN;
                int i = 1;
                for(auto& [k,v]:map)
                {
                    if(v.size() == 1)
                    {
                        res[0] = k;
                        res[1] = v[0];
                    }
                }
            
                while(res[n - 1] == INT32_MIN)
                {
                    if(map[res[i]][0] == res[i - 1])
                    {
                        res[i + 1] = map[res[i]][1];
                    }
                    else               
                    {
                        res[i + 1] = map[res[i]][0];
                    }
                    
                    i++;
                }
                return res;
        
            }
        };
        ```


​        
[盒子中小球的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balls-in-a-box/)这个就比较简单了，直接暴力也很快


​    
